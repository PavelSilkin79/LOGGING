Общая схема настройки логирования
Обдумываем как и для чего нам нужно логирование, то есть где и какие логи мы хотим смотреть.

Создаем форматтеры (как будут выглядеть логи), фильтры (какие логи нужно пропускать в хэндлеры, а какие нет) и хэндлеры (куда направлять логи). Лучше для этого использовать конфигурационные файлы логирования (python-словарь, YAML и т.п.), в которых описываются все настройки.

Если тонкая настройка логов не требуется, то достаточно задать базовые параметры логирования в точке входа и определить уровень логирования для всего проекта (basicConfig). В процессе разработки это обычно DEBUG, а в продакшне WARNING.

Создаем логгеры в каждом модуле проекта, где хотим использовать логирование с помощью функции getLogger библиотеки logging, передавая ей желаемое имя логгера в качестве аргумента. Рекомендуется в качестве имени передавать магическую переменную __name__, тогда имя логгера будет совпадать с именем модуля, в котором инициализирован логгер.

Вставляем логи в тех местах проекта, где они требуются, с тем уровнем, который требуется, вызывая у логгеров соответствующие методы.



Основные мысли урока
Логирование - важный инструмент разработки, позволяющий отслеживать что, где и когда произошло в вашем приложении.

Логи - это записи о поведении (состоянии) вашего приложения в определенный момент.

От логирования принтами нужно как можно скорее переходить к нормальным инструментам логирования, потому что принты неудобны в любых проектах уровня, хотя бы немного превышающего самый начальный.

В Python есть стандартная библиотека logging, предоставляющая необходимые инструменты для гибкой настройки логирования в проекте.

Основные понятия, с которыми надо разобраться, чтобы эффективно использовать библиотеку logging - это:

Логгеры
Уровни логирования
Форматтеры
Хэндлеры
Фильтры
Логгеры - это объекты, предоставляющие интерфейс, через который можно управлять логами.

При каждом вызове метода логирования у логгера (debug, info, critical и т.п.) создается объект класса LogRecord, содержащий большое количество полезной информации, которую затем можно выводить куда-либо. Также по этой информации можно фильтровать логи.

Для логирования исключений у логгера есть специальный метод exception.

Основных уровней логирования 5:

DEBUG (для отладочной информации)
INFO (для сообщений о том, что работа приложения в этом месте проходит в штатном режиме)
WARNING (для предупреждений о возможных проблемах в скором времени)
ERROR (для сообщения о некритических ошибках в работе приложения)
CRITICAL (для сообщения о критических ошибках в работе приложения. Обычно после таких ошибок приложение останавливает свою работу или перезапускается)
Существует уровень логирования NOTSET, который говорит о том, что уровень не установлен. Когда в процессе работы программы встречается такой уровень, берется уровень логгера, стоящего выше по иерархии логгеров.

Логгеры выстраиваются в иерархию. Корневым логгером является root-логгер.

Когда вы пытаетесь проинициализировать новый логгер - сначала ищется уже существующий логгер с таким именем и только если его нет - создается новый.

При инициализации логгера следует называть его по имени модуля, в котором он иницилизируется, с помощью магической переменной __name__, тогда будет проще искать откуда именно пришел лог:

logger = logging.getLogger(__name__)
Чтобы настроить то, как будут выглядеть логи, нужно использовать форматтеры. Для этого им передается шаблон строки, по которому будут формироваться логи и стиль, которому соответствует шаблон. Данные для шаблона будут получены из экземпляра класса LogRecord и подставлены в шаблон перед выводом лога.

Форматтеры работают совместно с хэндлерами.

Хэндлеры служат для того, чтобы определять куда перенаправлять вывод логов, в зависимости от настроек хэндлера. Это может быть стандартный поток вывода stdout, стандартный поток ошибок stderr, файл, электронная почта, база данных и так далее.

У логгеров и хэндлеров могут быть установлены уровни логирования.

Логгер не пропустит лог, который ниже по уровню, чем уровень самого логгера, то есть лог вида:

logger.debug('Лог уровня DEBUG')
Не приведет к созданию экземпляра LogRecord, если у logger будет установлен уровень выше DEBUG.

Также лог не будет никуда отправлен, если у хэндлера уровень выше, чем уровень логгера. Чтобы хэндлер обработал лог уровень хэндлера должен либо совпадать с уровнем логгера, либо быть ниже уровня логгера.

Управлять уровнем, от которого нужно выводить логи в проекте, можно с помощью функции basicConfig, которая определяет базовую конфигурацию логирования для всего проекта. Такая базовая конфигурация будет распространяться на все логгеры, за которыми не закреплены свои хэндлеры.

Дополнительно фильтровать логи на уровне логгеров и хэндлеров можно с помощью фильтров.

В фильтры попадает экземпляр класса LogRecord конкретного лога, и по атрибутам этого экземпляра можно тонко настраивать фильтрацию логов.

В момент создания лога в LogRecord можно передавать дополнительные данные, которые затем можно также использовать в фильтрах и хэндлерах.

Удобно конфигурировать логирование для проекта в отдельном модуле, прописывая все настройки либо в словаре python, либо в YAML-файле, либо просто в текстовом файле и загружая их в проект с помощью dictConfig или fileConfig.
